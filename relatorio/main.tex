\documentclass[a4paper]{article}
\usepackage[portuges]{babel}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fancyvrb}
\usepackage{url}

\usepackage{aeguill}  % usefull for pdflatex
%\usepackage[compat2,twosideshift=0mm,left=20mm,right=20mm,bottom=20mm,top=15mm]{geometry}

\usepackage{algorithmic}
\usepackage{algorithm}
\usepackage{float}
\usepackage{verbatim}


\parindent=2em


\title{MDIO}
\author{Gabriel Poça \and Pedro Nunes \and Sofia Vieira}

\date{\today}

\begin{document}

\maketitle

\begin{abstract}

\end{abstract}

\parskip=0mm
%\tableofcontents
\parskip=2mm



\section{Exercicio 2} { 
	No exercicio 2. deve considerar-se uma sub-instância do problema original e uma frota de duas viaturas e establecer um modelo de Programação Linear que permita encontrar a solução óptima.
	Consideremos as seguintes variáveis:
	\begin{description}
	\item[\rm $n$] Numero de vértices a visitar, sendo que o vértice $0$ representa o vértice inicial e o vértice $n$ o final.
	\item[$m$] Numero de viaturas.
	\item[$L_{i}$] Prémio em cada vértice para $i = 0,\ldots,n$.
	\item[\rm $Tmax$] Distância máxima que cada viatura pode percorrer.
	\item[$t_{ij}$] Distância entre o vértice $i$ e $j$.
	\item[$x_{ijk}$] Variável binária que representa a passagem, ou não, da viatura $k$ entre o ponto $i$ e $j$.
	\end{description}
	O modelo de Programação Linear é:
	\begin{itemize}
	\item $\sum_{ i=0 }^n\sum_{ j=0 }^n\sum_{ k=0 }^m Lj * x_{ijk}$
	\end{itemize}
	\textit{s.a:} 
	\begin{enumerate}
	\item $\sum_{ i=0 }^{n-1}\sum_{ k=1 }^m x_{ijk} <= 1 				\hfill j=1,\ldots,n$ \\ 
	\item $\sum_{ i=0 }^n x_{ ipk }  = \sum_{ j=0 }^n x_{pjk} 			\hfill p=0,\ldots,n \qquad k=1,\ldots,m$ \\ 
	\item $\sum_{ i=0 }^n\sum_{ j=0 }^n t_{ij} * x_{ijk} <= Tmax 	\hfill k=1,\ldots,m$ \\ 
	\item $\sum_{ i=1 }^{n-1} x_{ 0ik } = 1							\hfill k=1,\ldots,m$ \\ 
	\item $\sum_{ i=1 }^{n-1} x_{ ink } = 1							\hfill k=1,\ldots,m$ \\ 
	\end{enumerate}

	A restrição 1. garante que apenas uma das viaturas pode visitar um ponto. A restrição 2. garante que existe, para cada viatura, um percurso de saida de cada vertice visitado para outro vertice. A restrição em 3. garante que é respeitado um limite máximo de distância percorrida para cada viatura. As restrições em 4. e 5. garantem que uma viatura deve ser 'sair' do vertice inicial e terminar no vértice final. 

	Este relatório é acompanhado de um documento denominado \textit{ex2.lp} onde se encontra o código para o lp\_solve.


\section{Exercicio 3}
O pseudo código na Figura~\ref{pseudocodigo} representa uma possivél solução para um problema TOP.

\begin{algorithm}[H]
\floatname{algorithm}{Algoritmo}
\caption{Pseudo código para os caminhos mais curtos.}
\label{caminhoscurtos}
\begin{algorithmic}
	\STATE $nV \gets$ Numero de viaturas.
	\STATE $graph \gets$ Array com todos os vétices a visitar.
	\STATE $dMax \gets$ Valor da distância máxima que cada viatura pode percorrer.
	\STATE $paths :=$ Conjunto que detém os percursos determinados.
	\FOR{$i = 0; i < nV; i \gets i+1$}
		\STATE $path :=$ Novo percurso composto por sequência de vértices vazia.
		\STATE $path \gets path + $ Vértice inicial.
		\WHILE{Procura não terminada}
			\IF{Distância no percurso com distância ao vertice final $< dMax$}
				\STATE $path \gets path + $ Vértice mais próximo do ultimo no percurso.
			\ELSE
				\STATE Remover o ultimo vértice inserido.
				\STATE $path \gets path +$ Vértice final.
			\ENDIF
		\ENDWHILE
		\STATE $paths \gets paths + path$
	\ENDFOR
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]                  
\floatname{algorithm}{Algoritmo}
\caption{Pseudo código para o exercício 3.}        
\label{pseudocodigo}    
\begin{algorithmic}
\STATE $graph =$ Array com todos os vértices. 
\STATE $dMax =$ Valor da distância máxima que cada viatura pode percorrer.
\STATE $paths\gets$ Caminhos mais curtos a partir do algoritmo anterior.
\WHILE{Existir vertices não visitados por analisar}
	\STATE $bestV \gets$ Vértice de maior lucro não visitado.	
	\FOR{$path : paths$ (para todos os percursos)}	
		\FOR{$v : path$ (para todos os vértices do percurso)}	
			\IF{$vb$ melhor que $v$ (no sentido em que apresenta maior lucro)}	
				\STATE Trocar o $v$ por $vb$.	
				\IF{Solução inválida}	
					\STATE Repor $v$.	
				\ELSE
					\STATE Terminar procura e passar ao vértice seguinte.
				\ENDIF	
			\ENDIF	
		\ENDFOR	
	\ENDFOR	
\ENDWHILE
\end{algorithmic}
\end{algorithm}

%\section{Conclusões}

\appendix
%\section{Código do Programa}

\end{document}
